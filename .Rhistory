library(MKinfer)
install.packages("MKinfer")
?var.test
?barlett.test
?levene.test
5/6
?bartlett.test
sum_lm = lm(mpg ~ am, data = mtcars)
sum_lm = summary(sum_lm)
sum_lm$coefficients
sum_lm$df
sum_lm
mod1 = lm(mpg ~ am, data = mtcars)
mod1$call
?escalc
library(metafor)
?escalc
escalc(
measure = "CVR",
n1i = 50,
n2i = 50,
sd1i = 1,
sd2i = 1.5,
m1i = 50,
m2i = 51,
)
mod1$df.residual
abs(rnorm(1000))
hist(abs(rnorm(1000)))
hist(sqrt(abs(rnorm(1000))))
shapiro.test(sqrt(abs(rnorm(1000))))
shapiro.test(sqrt(abs(rnorm(1000))))
shapiro.test(sqrt(abs(rnorm(1000))))
shapiro.test(sqrt(abs(rnorm(1000))))
?skedastic::breusch_pagan()
mtcars_lm <- lm(mpg ~ wt + qsec + am, data = mtcars)
breusch_pagan(mtcars_lm)
library(skedasitc)
library(skedastic)
mtcars_lm <- lm(mpg ~ wt + qsec + am, data = mtcars)
breusch_pagan(mtcars_lm)
breusch_pagan(mtcars_lm, koenker = FALSE)
# Same as first example
mtcars_list <- list("y" = mtcars$mpg, "X" = cbind(1, mtcars$wt, mtcars$qsec, mtcars$am))
breusch_pagan(mtcars_list)
breusch_pagan(mtcars_lm,
auxdesign = data.frame(wt = mtcars$wt))
data.frame(wt = mtcars$wt)
breusch_pagan(mtcars_lm,
auxdesign = data.frame(z = mtcars$wt))
data.frame(z = mtcars$wt)
auxdesign = data.frame(z = mtcars$wt)
mainlm = mtcars_lm
auxfitvals <- ifelse(all(is.na(auxdesign)) | is.null(auxdesign),
FALSE, auxdesign == "fitted.values")
processmainlm(m = mainlm, needy = auxfitvals, needyhat = auxfitvals,
needp = FALSE)
auxfitvals
breusch_pagan(mtcars_lm,
auxdesign =  mtcars$wt)
breusch_pagan(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt))
as.matrix(mtcars$wt)
glejser(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt))
## tests ------
# var.test - F-test
# barlett bartlett.test()
# levene car::levene
# fligner-killeen fligner.test()
# glejser (model based)
glejser.test <- function(model, Z_var, dataset){
# model is the lmer object
# Z_var is the explanatory variable to regress the abs values on
# dataset is the full data
ares <- abs(residuals(model))
sum_lm <- summary(lm(as.formula(paste0("ares ~ ", Z_var)), data = dataset))
statistic = sum_lm$coefficients[2, "t value"]
names(statistic) = "t"
pvalue = sum_lm$coefficients[2, "Pr(>|t|)"]
estimate = sum_lm$coefficients[2, "Estimate"]
names(estimate) = "Coefficient"
SE = sum_lm$coefficients[2, "Std. Error"]
rval <- list(statistic = sum_lm$coefficients[2, "t value"],
parameter = model$df.residual,
p.value = as.numeric(pvalue),
estimate = estimate,
stderr = sum_lm$coefficients[2, "Std. Error"],
null.value = 0,
alternative = alternative,
method = "Glejser Test for Differences in Variance",
data.name = model$call)
class(rval) <- "htest"
return(rval)
}
glejser.test(mtcars_lm,
"wt",
mtcars)
## tests ------
# var.test - F-test
# barlett bartlett.test()
# levene car::levene
# fligner-killeen fligner.test()
# glejser (model based)
glejser.test <- function(model, Z_var, dataset){
# model is the lmer object
# Z_var is the explanatory variable to regress the abs values on
# dataset is the full data
ares <- abs(residuals(model))
sum_lm <- summary(lm(as.formula(paste0("ares ~ ", Z_var)), data = dataset))
statistic = sum_lm$coefficients[2, "t value"]
names(statistic) = "t"
pvalue = sum_lm$coefficients[2, "Pr(>|t|)"]
estimate = sum_lm$coefficients[2, "Estimate"]
names(estimate) = "Coefficient"
SE = sum_lm$coefficients[2, "Std. Error"]
rval <- list(statistic = sum_lm$coefficients[2, "t value"],
parameter = model$df.residual,
p.value = as.numeric(pvalue),
estimate = estimate,
stderr = sum_lm$coefficients[2, "Std. Error"],
null.value = 0,
alternative = "greater",
method = "Glejser Test for Differences in Variance",
data.name = model$call)
class(rval) <- "htest"
return(rval)
}
glejser.test(mtcars_lm,
"wt",
mtcars)
as.character(mtcars_lm$call)
mtcars_lm$call
class(mtcars_lm$call)
?match.call
?print.call
deparse(substitute(mtcars_lm))
deparse(mtcars_lm)
## tests ------
# var.test - F-test
# barlett bartlett.test()
# levene car::levene
# fligner-killeen fligner.test()
# glejser (model based)
glejser.test <- function(model, Z_var, dataset){
# model is the lmer object
# Z_var is the explanatory variable to regress the abs values on
# dataset is the full data
ares <- abs(residuals(model))
sum_lm <- summary(lm(as.formula(paste0("ares ~ ", Z_var)), data = dataset))
statistic = sum_lm$coefficients[2, "t value"]
names(statistic) = "t"
pvalue = sum_lm$coefficients[2, "Pr(>|t|)"]
estimate = sum_lm$coefficients[2, "Estimate"]
names(estimate) = "Coefficient"
SE = sum_lm$coefficients[2, "Std. Error"]
rval <- list(statistic = sum_lm$coefficients[2, "t value"],
parameter = model$df.residual,
p.value = as.numeric(pvalue),
estimate = estimate,
stderr = sum_lm$coefficients[2, "Std. Error"],
null.value = 0,
alternative = "greater",
method = "Glejser Test for Differences in Variance",
data.name = as.character(model$call)[2])
class(rval) <- "htest"
return(rval)
}
glejser.test(mtcars_lm,
"wt",
mtcars)
test1=glejser(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt))
test1
?glejser
test1=glejser(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt),
statonly=FALSE)
class(test1)
Z_var = "wt"
dataset = mtcars
dataset[Z_var]
model = mtcars_lm
ares <- abs(residuals(model))
auxres <- stats::lm.fit(Z, ares)$residuals
ares <- abs(residuals(model))
Z = dataset[Z_var]
auxres <- stats::lm.fit(Z, ares)$residuals
Z
ares <- abs(residuals(model))
Z = as.numeric(dataset[Z_var])
Z = as.matrix(dataset[Z_var])
auxres <- stats::lm.fit(Z, ares)$residuals
auxres
## tests ------
# var.test - F-test
# barlett bartlett.test()
# levene car::levene
# fligner-killeen fligner.test()
# glejser (model based)
glejser.test <- function(model, Z_var, dataset){
# model is the lmer object
# Z_var is the explanatory variable to regress the abs values on
# dataset is the full data
ares = auxresponse = abs(residuals(model))
Z = as.matrix(dataset[Z_var])
if(length(Z_var == 1)){
Z <- cbind(1, Z)
}
q = ncol(Z)-1
auxres <- stats::lm.fit(Z, ares)$residuals
#sum_lm <- summary(lm(as.formula(paste0("ares ~ ", Z_var)), data = dataset))
sigma_hatsq <- sum(residuals(model)^2)/n
teststat <- (sum(auxresponse^2) - n * mean(auxresponse)^2 -
sum(auxres^2))/(sigma_hatsq * (1 - 2/pi))
pval <- stats::pchisq(teststat, df = q, lower.tail = FALSE)
statistic = teststat
names(statistic) = "Chi-squared"
rval <- list(statistic = statistic,
parameter = q,
p.value = as.numeric(pval),
null.value = "Homoskedasticity",
alternative = "greater",
method = "Glejser Test for Differences in Variance",
data.name = as.character(model$call)[2])
class(rval) <- "htest"
return(rval)
}
glejser.test(mtcars_lm,
"wt",
mtcars)
## tests ------
# var.test - F-test
# barlett bartlett.test()
# levene car::levene
# fligner-killeen fligner.test()
# glejser (model based)
glejser.test <- function(model, Z_var, dataset){
# model is the lmer object
# Z_var is the explanatory variable to regress the abs values on
# dataset is the full data
ares = auxresponse = abs(residuals(model))
n = length(ares)
Z = as.matrix(dataset[Z_var])
if(length(Z_var == 1)){
Z <- cbind(1, Z)
}
q = ncol(Z)-1
auxres <- stats::lm.fit(Z, ares)$residuals
#sum_lm <- summary(lm(as.formula(paste0("ares ~ ", Z_var)), data = dataset))
sigma_hatsq <- sum(residuals(model)^2)/n
teststat <- (sum(auxresponse^2) - n * mean(auxresponse)^2 -
sum(auxres^2))/(sigma_hatsq * (1 - 2/pi))
pval <- stats::pchisq(teststat, df = q, lower.tail = FALSE)
statistic = teststat
names(statistic) = "Chi-squared"
rval <- list(statistic = statistic,
parameter = q,
p.value = as.numeric(pval),
null.value = "Homoskedasticity",
alternative = "greater",
method = "Glejser Test for Differences in Variance",
data.name = as.character(model$call)[2])
class(rval) <- "htest"
return(rval)
}
glejser.test(mtcars_lm,
"wt",
mtcars)
## tests ------
# var.test - F-test
# barlett bartlett.test()
# levene car::levene
# fligner-killeen fligner.test()
# glejser (model based)
glejser.test <- function(model, Z_var, dataset){
# model is the lmer object
# Z_var is the explanatory variable to regress the abs values on
# dataset is the full data
ares = auxresponse = abs(residuals(model))
n = length(ares)
Z = as.matrix(dataset[Z_var])
if(length(Z_var == 1)){
Z <- cbind(1, Z)
}
q = ncol(Z)-1
auxres <- stats::lm.fit(Z, ares)$residuals
#sum_lm <- summary(lm(as.formula(paste0("ares ~ ", Z_var)), data = dataset))
sigma_hatsq <- sum(residuals(model)^2)/n
teststat <- (sum(auxresponse^2) - n * mean(auxresponse)^2 -
sum(auxres^2))/(sigma_hatsq * (1 - 2/pi))
pval <- stats::pchisq(teststat, df = q, lower.tail = FALSE)
statistic = teststat
names(statistic) = "Chi-squared"
null1 = 0
names(null1) = "heteroskedasticity"
rval <- list(statistic = statistic,
parameter = q,
p.value = as.numeric(pval),
null.value = null1,
alternative = "greater",
method = "Glejser Test for Heteroskedasticity",
data.name = as.character(model$call)[2])
class(rval) <- "htest"
return(rval)
}
glejser(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt),
statonly=FALSE)
glejser.test(mtcars_lm,
"wt",
mtcars)
breusch_pagan(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt))
?breusch_pagan
breusch_pagan(mtcars_lm,
auxdesign =  as.matrix(mtcars$wt),
koenker = FALSE)
hist(rnorm(1000)^2)
white(mtcars_lm)
?metafor::escalc
n1 = 200
n2 - 200
n2 = 200
sd1 = 1.5
sd2 = 1.6
es_est = metafor::escalc(
measure = "VR",
n1i = n1,
n2i = n2,
sd1i = sd1,
sd2i = sd2
)
es_est
log_vr_test = function(sd1, n1,
sd2, n2,
alternative = c("two.sided",
"greater",
"less")){
# old code
# var1 = sd1^2
# var1_se <- var1*(sqrt(2/(n1 - 1)))
# var2 = sd2^2
# var2_se <- var2*(sqrt(2/(n2 - 1)))
# yi <- log(sqrt(var1)/sqrt(var2)) + 1/(2 * (n1 - 1)) - 1/(2 *
#                                                                     (n2 - 1))
#
# vi <- 1/(2 * (n1 - 1)) + 1/(2 * (n2 - 1))
#
# teststat <- yi/sqrt(vi)
# metafor code
es_est = metafor::escalc(
measure = "VR",
n1i = n1,
n2i = n2,
sd1i = sd1,
sd2i = sd2
)
teststat <- es_est$yi/sqrt(es_est$vi)
pval = p_from_z(teststat,
alternative = alternative)
statistic = teststat
names(statistic) = "z"
null1 = 0
names(null1) = "log ratio of variances"
sum_stats = paste0("SD1 = ", sd1, ", SD2 = ", sd2)
rval <- list(statistic = statistic,
p.value = as.numeric(pval),
null.value = null1,
alternative = alternative,
method = "log Ratio of Variances",
data.name = sum_stats)
class(rval) <- "htest"
return(rval)
}
log_vr_test(1.5, 200, 2, 200)
# Functions -----
p_from_z = function(x,
alternative = "two.sided"){
if(alternative == "two.sided"){
2*pnorm(-abs(unlist(x)))
} else  if (alternative  == "greater"){
pnorm(x, lower.tail = FALSE)
} else if (alternative  == "less"){
pnorm(x, lower.tail = TRUE)
} else{
stop("alternative must be two.sided, greater, or less")
}
}
log_vr_test(1.5, 200, 2, 200)
log_vr_test = function(sd1, n1,
sd2, n2,
alternative = c("two.sided",
"greater",
"less")){
# old code
# var1 = sd1^2
# var1_se <- var1*(sqrt(2/(n1 - 1)))
# var2 = sd2^2
# var2_se <- var2*(sqrt(2/(n2 - 1)))
# yi <- log(sqrt(var1)/sqrt(var2)) + 1/(2 * (n1 - 1)) - 1/(2 *
#                                                                     (n2 - 1))
#
# vi <- 1/(2 * (n1 - 1)) + 1/(2 * (n2 - 1))
#
# teststat <- yi/sqrt(vi)
alternative = match.arg(alternative)
# metafor code
es_est = metafor::escalc(
measure = "VR",
n1i = n1,
n2i = n2,
sd1i = sd1,
sd2i = sd2
)
teststat <- es_est$yi/sqrt(es_est$vi)
pval = p_from_z(teststat,
alternative = alternative)
statistic = teststat
names(statistic) = "z"
null1 = 0
names(null1) = "log ratio of variances"
sum_stats = paste0("SD1 = ", sd1, ", SD2 = ", sd2)
rval <- list(statistic = statistic,
p.value = as.numeric(pval),
null.value = null1,
alternative = alternative,
method = "log Ratio of Variances",
data.name = sum_stats)
class(rval) <- "htest"
return(rval)
}
log_vr_test(1.5, 200, 2, 200)
?t.test
with(sleep, t.test(extra[group == 1], extra[group == 2]))
test1 =with(sleep, t.test(extra[group == 1], extra[group == 2]))
test1$stderr
log_vr_test = function(sd1, n1,
sd2, n2,
alternative = c("two.sided",
"greater",
"less")){
# old code
# var1 = sd1^2
# var1_se <- var1*(sqrt(2/(n1 - 1)))
# var2 = sd2^2
# var2_se <- var2*(sqrt(2/(n2 - 1)))
# yi <- log(sqrt(var1)/sqrt(var2)) + 1/(2 * (n1 - 1)) - 1/(2 *
#                                                                     (n2 - 1))
#
# vi <- 1/(2 * (n1 - 1)) + 1/(2 * (n2 - 1))
#
# teststat <- yi/sqrt(vi)
alternative = match.arg(alternative)
# metafor code
es_est = metafor::escalc(
measure = "VR",
n1i = n1,
n2i = n2,
sd1i = sd1,
sd2i = sd2
)
teststat <- es_est$yi/sqrt(es_est$vi)
pval = p_from_z(teststat,
alternative = alternative)
statistic = teststat
names(statistic) = "z"
null1 = 0
names(null1) = "log ratio of variances"
estimate = es_est$yi
names(estimate)= "log VR"
std_err = sqrt(es_est$vi)
sum_stats = paste0("SD1 = ", sd1, ", SD2 = ", sd2)
rval <- list(statistic = statistic,
p.value = as.numeric(pval),
stderr = std_err,
null.value = null1,
alternative = alternative,
method = "log Ratio of Variances",
data.name = sum_stats)
class(rval) <- "htest"
return(rval)
}
log_vr_test(1.5, 200, 2, 200)
sqrt(-1)
sd1
df1
df = n1 -1
df1 = n1 -1
df2 = n2 - 1
sqrt(2 * (sd1^4/df1 + sd2^4/df2))
var1 = sd1^2
var1_se <- var1*(sqrt(2/(n1 - 1)))
var2 = sd2^2
var2_se <- var2*(sqrt(2/(n2 - 1)))
sqrt(var1^2 + var2^2)
var1*(sqrt(2/(n1 - 1)))
var2*(sqrt(2/(n2 - 1)))
sqrt(var1_se^2 + var2_se^2)
